C语言第六章 数据类型
===========================
### 6.1 数据类型


1. **C是有<U>类型</U>的语言**：变量需要在使用前定义，且确定类型

2. **C后语言的发展方向**：
    > * 强调类型 *（早期、面向底层）*：C++/Java
    > * 不重类型，甚至无需事先定义 *(面向应用，强调事务逻辑)*：JS、Python、PHP
3. **强类型利弊**
    > * <font color=red>利：能尽早发现程序中的简单错误</font>
    > * <font color=blue>弊：迫使程序员面对底层、实现而非事务逻辑</font>
4. **C语言中的类型**
    > ①整数：char、short、int、long、<font color=blue>long long</font>
    > ②浮点数：float、double、<font color=blue>long double</font>
    > ③逻辑：<font color=blue>bool</font>
    > ④指针
    > ⑤自定义
    >
    > *<font color=blue>蓝色字体：C99</font>*
5. **不同类型的不同之处**
    > * 名称
    > * 格式化
    > * 范围
    > * 内存中占据的大小
    > * 内存中表达形式
6. **sizeof（）**：可以给出某个类型或变量在内存中占据的字节数
    > ps.是静态运算符，结果在编译时已确定
    > pss.括号内运算不会被进行


### 6.2 整数
#### 6.2.1 整数的类型
> ① char：1字节 *（8bit——二进制的位）*
> ② short：2字节
> ③ int：大小取决于编译器（32位、64位，指CPU中1个寄存器可表达的数据），通常意义是“1个字”——表达寄存器
> ④ long：同int
> ⑤ long long：8字节
#### 6.2.2 整数的内部表达
1.**计算机内部一切都是二进制**
2.**补码：表达二进制负数**（和原码能加出一个<font color=red>溢出</font>的“0”）

     解释：
     1 => 0000 0001
     希望-1+1=0，即1+（-1）=（1）0000 0000
     ∴-1 => 1111 1111

     另一种解释：
     -1 = （1）0000 0000 - 0000 0001 = 1111 1111
3. **对于a，其补码为2^n - a，n为该类型的位数**

#### 6.2.3 整数的范围
1. **1个字节（8bit）可表达：0000 0000~1111 1111**
    > * 0000 0000 => 0
    > * （补码）1111 1111 ~ 1000 0000 => -1~-128
    > * 0000 0001 ~ 0111 1111 => 1~127
2. **unsigned：把量看待为纯二进制，<font color=red>只有0和正整数部分</font>（正数部分扩大，负数无法表达）**
    > 例：255U(u)；
    > 　　用l或L表示long(long)；
    >　　unsigned char c = 255，输出为c=255

    初衷：做纯二进制运算，主要为了移位
3. **整数越界**

![IMAGE 例图](https://github.com/Baiyun2333/images/blob/main/zhengshuyuejie.jpg?raw=true)

     0111 1111(127) + 1 　　=> -128
     unsigned char c = 256　=>  c=0

#### 6.2.4 整数格式化
1. **在做<U>整数</U>输入输出时，只有2种形式**：<U>int</U> 或<U>long long</U>
    > * 小于int：%d，unsigned为%u
    > * 大于int：%ld，unsigned为%lu
2. **以0开始的数字的字面量是8进制，以0x开始则是16进制**
    > 012 → 10
    > 0x12 → 18

    **输出8进制：%o
    输出16进制：%x（%X）**
3. **16进制适合用于表达2进制数据（4个2进制位是1个16进制位）**

#### 6.2.5整数类型选择
**没有特殊需要，就选择<font color=red><U>int</U></font>**

 > * 一次内存读写就是1个int，一次计算也是1个int
 > * 更短的类型在内存中有可能也占据1个int的大小

### 6.3 浮点
#### 6.3.1 浮点类型
1. **两种浮点类型的比较**

| 类型　| 字长 | 有效数字 | 输入表示 | 输出表示 |
| :----: | :----: | :----: | :----: | :----: |
| float | 32 | 7 | %f | %f、%e（科学计数法） | 
| double | 64 | 15 | %lf | %f、%e（科学计数法） |
**有效数字**：只有n个数字是有效的，第n+1个数字不准确
**科学计数法**：形如1e+10的数（这个值的意思是1×10^10）

2. **printf中的%f可写为<U>%.▢f</U>**：输出▢位小数（会进行四舍五入）

3. **计算机用离散的数字去表达数字**（二进制无法精确表达十进制小数）

#### 6.3.2 浮点的范围及精度
1. 
 > * inf：表示超过范围的浮点数（∞）
 > * nan: 不存在的浮点数
 >
 > *12.0/0.0 → +∞*

2. **带小数点的字面量属于double，要用float需要用f（F）后缀表明**（如1.123f）
3. **直接判断一个浮点数等于另一个浮点数（f1==f2）可能会失效**
    > **正确的判断方法**：fabs（f1-f2） < 1e-12  <font color=red>（比精度小）</font>
    > （ps：fabs()是取绝对值）
4. **浮点数在计算时由专用硬件部件实现**
![IMAGE 例图](https://github.com/Baiyun2333/images/blob/main/fudianyingjian.png?raw=true)
5. **如无特殊需要，一般只使用double**

### 6.4 字符
#### 6.4.1 字符类型
1. **char既是一种整数，也是一特殊的类型——字符**
2. **‘a’、‘1’这种是单个的字符，‘’也是一个字符**
3. **printf和scanf中使用%c来输入输出字符**
4. **使用ASCII码，49==‘1’是成立的（它们只是形式不同）**
5. **字符也能进行整数的运算**
    > 'A' + 1 => 'B'
    > 'Z' - 'A' => 25 <font color=red>（它们在表中的距离）</font>
#### 6.4.2 逃逸字符
**逃逸字符**：用来表达无法打印出来的控制字符或特殊字符，以反斜杠“\”开头

   > * \b：回退1格（之后再输出，会覆盖先前此位置上的输出）
   > * \t：到下一个表格位（对齐）
   > * \n：换行
   > * \r：回车

### 6.5 逻辑
#### 6.5.1 逻辑类型
1. **#include<stdbool.h>后就可使用bool和true、false**

>  * bool b = 6>5  => 结果是逻辑值（1）
>  * bool t = true

2. **要输出，用整数（%d）表示** 

#### 6.5.2 逻辑运算
1. **逻辑量**：关系运算或逻辑运算的结果
2. **逻辑运算**：对逻辑量进行的运算，结果只有0或1
3. **运算符**：
> * ！：非
> * &&：与
> * ||：或
>
>*例：判断字符c是否为大写字母：c>='A' && c<= 'Z'*
4. **优先级**：！> && > ||
　　　　关系运算符 > 逻辑运算符
5. **短路**：逻辑运算自左向右，若左边已能决定结果，就不会做右边计算
> 例：a\=\=6 && b\=\=1，若a\=\=6不成立，不会判断b\=\=1
#### 6.5.3 条件和符号运算
1. **条件运算符**：
>（count>20）<font color=red>?</font> count-10 <font color=red>：</font> count + 10
>　　<font color=blue>条件　　　满足时　　　不满足时</font>
2. **条件运算符<U>自右向左</U>结合**
3. **逗号运算符**：连接两个表达式，并令其右边的表达式的值作为它的<U>结果</U>
> * 优先级最低
> * 计算由左到右
> * 主要在for中使用，进行多个运算
>
>i = 3+4，5+6 　　　=> i=7
>i = (3+4,5+6)　　　 => i=11 